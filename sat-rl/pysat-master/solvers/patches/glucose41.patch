diff -Naur solvers/glucose41/Makefile solvers/g41/Makefile
--- solvers/glucose41/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ solvers/g41/Makefile	2018-05-21 10:14:01.000000000 +0100
@@ -0,0 +1,39 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+CXX      := c++
+CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing -DINCREMENTAL
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/Solver.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     :=  glucose41
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS)
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
+
+#-------------------------------------------------------------------------------
diff -Naur solvers/glucose41/core/BoundedQueue.h solvers/g41/core/BoundedQueue.h
--- solvers/glucose41/core/BoundedQueue.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/core/BoundedQueue.h	2018-05-21 10:14:01.000000000 +0100
@@ -48,14 +48,14 @@
  **************************************************************************************************/
 
 
-#ifndef BoundedQueue_h
-#define BoundedQueue_h
+#ifndef Glucose41_BoundedQueue_h
+#define Glucose41_BoundedQueue_h
 
-#include "mtl/Vec.h"
+#include "glucose41/mtl/Vec.h"
 
 //=================================================================================================
 
-namespace Glucose {
+namespace Glucose41 {
 
 template <class T>
 class bqueue {
diff -Naur solvers/glucose41/core/Solver.cc solvers/g41/core/Solver.cc
--- solvers/glucose41/core/Solver.cc	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/core/Solver.cc	2018-05-23 14:37:43.000000000 +0100
@@ -9,19 +9,19 @@
                                 Labri - Univ. Bordeaux, France
 
 Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
-Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it
 is based on. (see below).
 
 Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
 version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
 without restriction, including the rights to use, copy, modify, merge, publish, distribute,
-sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 - The above and below copyrights notices and this permission notice shall be included in all
 copies or substantial portions of the Software;
 - The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
-be used in any competitive event (sat competitions/evaluations) without the express permission of 
+be used in any competitive event (sat competitions/evaluations) without the express permission of
 the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
 using Glucose Parallel as an embedded SAT engine (single core or not).
 
@@ -49,13 +49,12 @@
 
 #include <math.h>
 
-#include "utils/System.h"
-#include "mtl/Sort.h"
-#include "core/Solver.h"
-#include "core/Constants.h"
-#include"simp/SimpSolver.h"
+#include "glucose41/utils/System.h"
+#include "glucose41/mtl/Sort.h"
+#include "glucose41/core/Solver.h"
+#include "glucose41/core/Constants.h"
 
-using namespace Glucose;
+using namespace Glucose41;
 
 
 //=================================================================================================
@@ -150,6 +149,7 @@
 , randomizeFirstDescent(false)
 , garbage_frac(opt_garbage_frac)
 , certifiedOutput(NULL)
+, certifiedPyFile(NULL)
 , certifiedUNSAT(false) // Not in the first parallel version
 , vbyte(false)
 , panicModeLastRemoved(0), panicModeLastRemovedShared(0)
@@ -378,7 +378,7 @@
     watchesBin.init(mkLit(v, true));
     unaryWatches.init(mkLit(v, false));
     unaryWatches.init(mkLit(v, true));
-    assigns.push(l_Undef);
+    assigns.push(g41l_Undef);
     vardata.push(mkVarData(CRef_Undef, 0));
     activity.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
     seen.push(0);
@@ -386,6 +386,7 @@
     polarity.push(sign);
     forceUNSAT.push(0);
     decision.push();
+    assump.push(false);
     trail.capacity(v + 1);
     setDecisionVar(v, dvar);
     return v;
@@ -408,15 +409,15 @@
     if(certifiedUNSAT) {
         for(i = j = 0, p = lit_Undef; i < ps.size(); i++) {
             oc.push(ps[i]);
-            if(value(ps[i]) == l_True || ps[i] == ~p || value(ps[i]) == l_False)
+            if(value(ps[i]) == g41l_True || ps[i] == ~p || value(ps[i]) == g41l_False)
                 flag = 1;
         }
     }
 
     for(i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        if(value(ps[i]) == l_True || ps[i] == ~p)
+        if(value(ps[i]) == g41l_True || ps[i] == ~p)
             return true;
-        else if(value(ps[i]) != l_False && ps[i] != p)
+        else if(value(ps[i]) != g41l_False && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
@@ -434,12 +435,12 @@
         }
         else {
             for(i = j = 0, p = lit_Undef; i < ps.size(); i++)
-                fprintf(certifiedOutput, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
+                fprintf(certifiedOutput, "%i ", var(ps[i]) * (-2 * sign(ps[i]) + 1));
             fprintf(certifiedOutput, "0\n");
 
             fprintf(certifiedOutput, "d ");
             for(i = j = 0, p = lit_Undef; i < oc.size(); i++)
-                fprintf(certifiedOutput, "%i ", (var(oc[i]) + 1) * (-2 * sign(oc[i]) + 1));
+                fprintf(certifiedOutput, "%i ", var(oc[i]) * (-2 * sign(oc[i]) + 1));
             fprintf(certifiedOutput, "0\n");
         }
     }
@@ -540,7 +541,7 @@
         else {
             fprintf(certifiedOutput, "d ");
             for(int i = 0; i < c.size(); i++)
-                fprintf(certifiedOutput, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
+                fprintf(certifiedOutput, "%i ", var(c[i]) * (-2 * sign(c[i]) + 1));
             fprintf(certifiedOutput, "0\n");
         }
     }
@@ -559,12 +560,12 @@
 bool Solver::satisfied(const Clause &c) const {
 #ifdef INCREMENTAL
     if(incremental)
-        return (value(c[0]) == l_True) || (value(c[1]) == l_True);
+        return (value(c[0]) == g41l_True) || (value(c[1]) == g41l_True);
 #endif
 
     // Default mode
     for(int i = 0; i < c.size(); i++)
-        if(value(c[i]) == l_True)
+        if(value(c[i]) == g41l_True)
             return true;
     return false;
 }
@@ -628,7 +629,7 @@
         int nb = 0;
         for(int k = 0; k < wbin.size(); k++) {
             Lit imp = wbin[k].blocker;
-            if(permDiff[var(imp)] == MYFLAG && value(imp) == l_True) {
+            if(permDiff[var(imp)] == MYFLAG && value(imp) == g41l_True) {
                 nb++;
                 permDiff[var(imp)] = MYFLAG - 1;
             }
@@ -659,7 +660,7 @@
     if(decisionLevel() > level) {
         for(int c = trail.size() - 1; c >= trail_lim[level]; c--) {
             Var x = var(trail[c]);
-            assigns[x] = l_Undef;
+            assigns[x] = g41l_Undef;
             if(phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last())) {
                 polarity[x] = sign(trail[c]);
             }
@@ -681,12 +682,12 @@
     // Random decision:
     if(((randomizeFirstDescent && conflicts == 0) || drand(random_seed) < random_var_freq) && !order_heap.empty()) {
         next = order_heap[irand(random_seed, order_heap.size())];
-        if(value(next) == l_Undef && decision[next])
+        if(value(next) == g41l_Undef && decision[next])
             stats[rnd_decisions]++;
     }
 
     // Activity based decision:
-    while(next == var_Undef || value(next) != l_Undef || !decision[next])
+    while(next == var_Undef || value(next) != g41l_Undef || !decision[next])
         if(order_heap.empty()) {
             next = var_Undef;
             break;
@@ -718,19 +719,19 @@
 /*_________________________________________________________________________________________________
 |
 |  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
-|  
+|
 |  Description:
 |    Analyze conflict and produce a reason clause.
-|  
+|
 |    Pre-conditions:
 |      * 'out_learnt' is assumed to be cleared.
 |      * Current decision level must be greater than root level.
-|  
+|
 |    Post-conditions:
 |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
-|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
+|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the
 |        rest of literals. There may be others from the same level though.
-|  
+|
 |________________________________________________________________________________________________@*/
 void Solver::analyze(CRef confl, vec <Lit> &out_learnt, vec <Lit> &selectors, int &out_btlevel, unsigned int &lbd, unsigned int &szWithoutSelectors) {
     int pathC = 0;
@@ -746,9 +747,9 @@
         Clause &c = ca[confl];
         // Special case for binary clauses
         // The first one has to be SAT
-        if(p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+        if(p != lit_Undef && c.size() == 2 && value(c[0]) == g41l_False) {
 
-            assert(value(c[1]) == l_True);
+            assert(value(c[1]) == g41l_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp;
         }
@@ -805,7 +806,7 @@
                             lastDecisionLevel.push(q);
                     } else {
                         if(isSelector(var(q))) {
-                            assert(value(q) == l_False);
+                            assert(value(q) == g41l_False);
                             selectors.push(q);
                         } else
                             out_learnt.push(q);
@@ -931,8 +932,8 @@
         assert(reason(var(analyze_stack.last())) != CRef_Undef);
         Clause &c = ca[reason(var(analyze_stack.last()))];
         analyze_stack.pop(); //
-        if(c.size() == 2 && value(c[0]) == l_False) {
-            assert(value(c[1]) == l_True);
+        if(c.size() == 2 && value(c[0]) == g41l_False) {
+            assert(value(c[1]) == g41l_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp;
         }
@@ -963,7 +964,7 @@
 /*_________________________________________________________________________________________________
 |
 |  analyzeFinal : (p : Lit)  ->  [void]
-|  
+|
 |  Description:
 |    Specialized analysis procedure to express the final conflict in terms of assumptions.
 |    Calculates the (possibly empty) set of assumptions that led to the assignment of 'p', and
@@ -1003,7 +1004,7 @@
 
 
 void Solver::uncheckedEnqueue(Lit p, CRef from) {
-    assert(value(p) == l_Undef);
+    assert(value(p) == g41l_Undef);
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
@@ -1015,15 +1016,67 @@
     return;
 }
 
+//=================================================================================================
+// Propagate and check:
+bool Solver::prop_check(const vec<Lit>& assumps, vec<Lit>& prop, int psaving)
+{
+    prop.clear();
+
+    if (!ok)
+        return false;
+
+    bool    st = true;
+    int  level = decisionLevel();
+    CRef confl = CRef_Undef;
+
+    // dealing with phase saving
+    int psaving_copy = phase_saving;
+    phase_saving = psaving;
+
+    // propagate each assumption at a new decision level
+    for (int i = 0; st && confl == CRef_Undef && i < assumps.size(); ++i) {
+        Lit p = assumps[i];
+
+        if (value(p) == g41l_False)
+            st = false;
+        else if (value(p) != g41l_True) {
+            newDecisionLevel ();
+            uncheckedEnqueue(p);
+            confl = propagate();
+        }
+    }
+
+    // copying the result
+    if (decisionLevel() > level) {
+        for (int c = trail_lim[level]; c < trail.size(); ++c)
+            prop.push(trail[c]);
+
+        // if there is a conflict, pushing
+        // the conflicting literal as well
+        // here we may choose a wrong literal
+        // in Glucose if the clause is binary!
+        if (confl != CRef_Undef)
+            prop.push(ca[confl][0]);
+
+        // backtracking
+        cancelUntil(level);
+    }
+
+    // restoring phase saving
+    phase_saving = psaving_copy;
+
+    return st && confl == CRef_Undef;
+}
+
 
 /*_________________________________________________________________________________________________
 |
 |  propagate : [void]  ->  [Clause*]
-|  
+|
 |  Description:
 |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
 |    otherwise CRef_Undef.
-|  
+|
 |    Post-conditions:
 |      * the propagation queue is empty, even if there was a conflict.
 |________________________________________________________________________________________________@*/
@@ -1046,11 +1099,11 @@
 
             Lit imp = wbin[k].blocker;
 
-            if(value(imp) == l_False) {
+            if(value(imp) == g41l_False) {
                 return wbin[k].cref;
             }
 
-            if(value(imp) == l_Undef) {
+            if(value(imp) == g41l_Undef) {
                 uncheckedEnqueue(imp, wbin[k].cref);
             }
         }
@@ -1059,7 +1112,7 @@
         for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if(value(blocker) == l_True) {
+            if(value(blocker) == g41l_True) {
                 *j++ = *i++;
                 continue;
             }
@@ -1077,7 +1130,7 @@
             // If 0th watch is true, then clause is already satisfied.
             Lit first = c[0];
             Watcher w = Watcher(cr, first);
-            if(first != blocker && value(first) == l_True) {
+            if(first != blocker && value(first) == g41l_True) {
 
                 *j++ = w;
                 continue;
@@ -1087,14 +1140,14 @@
               int choosenPos = -1;
               for (int k = 2; k < c.size(); k++) {
 
-            if (value(c[k]) != l_False){
+            if (value(c[k]) != g41l_False){
               if(decisionLevel()>assumptions.size()) {
                 choosenPos = k;
                 break;
               } else {
                 choosenPos = k;
 
-                if(value(c[k])==l_True || !isSelector(var(c[k]))) {
+                if(value(c[k])==g41l_True || !isSelector(var(c[k]))) {
                   break;
                 }
               }
@@ -1109,7 +1162,7 @@
 #endif
             for(int k = 2; k < c.size(); k++) {
 
-                if(value(c[k]) != l_False) {
+                if(value(c[k]) != g41l_False) {
                     c[1] = c[k];
                     c[k] = false_lit;
                     watches[~c[1]].push(w);
@@ -1121,7 +1174,7 @@
 #endif
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if(value(first) == l_False) {
+            if(value(first) == g41l_False) {
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -1155,11 +1208,11 @@
 /*_________________________________________________________________________________________________
 |
 |  propagateUnaryWatches : [Lit]  ->  [Clause*]
-|  
+|
 |  Description:
-|    Propagates unary watches of Lit p, return a conflict 
+|    Propagates unary watches of Lit p, return a conflict
 |    otherwise CRef_Undef
-|  
+|
 |________________________________________________________________________________________________@*/
 
 CRef Solver::propagateUnaryWatches(Lit p) {
@@ -1169,7 +1222,7 @@
     for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
         // Try to avoid inspecting the clause:
         Lit blocker = i->blocker;
-        if(value(blocker) == l_True) {
+        if(value(blocker) == g41l_True) {
             *j++ = *i++;
             continue;
         }
@@ -1186,7 +1239,7 @@
         i++;
         Watcher w = Watcher(cr, c[0]);
         for(int k = 1; k < c.size(); k++) {
-            if(value(c[k]) != l_False) {
+            if(value(c[k]) != g41l_False) {
                 c[0] = c[k];
                 c[k] = false_lit;
                 unaryWatches[~c[0]].push(w);
@@ -1211,7 +1264,7 @@
             int maxlevel = -1;
             int index = -1;
             for(int k = 1; k < c.size(); k++) {
-                assert(value(c[k]) == l_False);
+                assert(value(c[k]) == g41l_False);
                 assert(level(var(c[k])) <= level(var(c[0])));
                 if(level(var(c[k])) > maxlevel) {
                     index = k;
@@ -1240,7 +1293,7 @@
 /*_________________________________________________________________________________________________
 |
 |  reduceDB : ()  ->  [void]
-|  
+|
 |  Description:
 |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
 |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
@@ -1305,7 +1358,7 @@
 void Solver::rebuildOrderHeap() {
     vec <Var> vs;
     for(Var v = 0; v < nVars(); v++)
-        if(decision[v] && value(v) == l_Undef)
+        if(decision[v] && value(v) == g41l_Undef)
             vs.push(v);
     order_heap.build(vs);
 
@@ -1315,7 +1368,7 @@
 /*_________________________________________________________________________________________________
 |
 |  simplify : [void]  ->  [bool]
-|  
+|
 |  Description:
 |    Simplify the clause database according to the current top-level assigment. Currently, the only
 |    thing done here is the removal of satisfied clauses, but more things can be put here.
@@ -1354,7 +1407,7 @@
 void Solver::adaptSolver() {
     bool adjusted = false;
     bool reinit = false;
-    printf("c\nc Try to adapt solver strategies\nc \n");
+    // printf("c\nc Try to adapt solver strategies\nc \n");
     /*  printf("c Adjusting solver for the SAT Race 2015 (alpha feature)\n");
     printf("c key successive Conflicts       : %" PRIu64"\n",stats[noDecisionConflict]);
     printf("c nb unary clauses learnt        : %" PRIu64"\n",stats[nbUn]);
@@ -1365,7 +1418,7 @@
         coLBDBound = 4;
         glureduce = true;
         adjusted = true;
-        printf("c Adjusting for low decision levels.\n");
+        // printf("c Adjusting for low decision levels.\n");
         reinit = true;
         firstReduceDB = 2000;
         nbclausesbeforereduce = firstReduceDB;
@@ -1379,10 +1432,10 @@
         var_decay = 0.999;
         max_var_decay = 0.999;
         adjusted = true;
-        printf("c Adjusting for low successive conflicts.\n");
+        // printf("c Adjusting for low successive conflicts.\n");
     }
     if(stats[noDecisionConflict] > 54400) {
-        printf("c Adjusting for high successive conflicts.\n");
+        // printf("c Adjusting for high successive conflicts.\n");
         chanseokStrategy = true;
         glureduce = true;
         coLBDBound = 3;
@@ -1396,12 +1449,12 @@
         var_decay = 0.91;
         max_var_decay = 0.91;
         adjusted = true;
-        printf("c Adjusting for a very large number of true glue clauses found.\n");
+        // printf("c Adjusting for a very large number of true glue clauses found.\n");
     }
     if(!adjusted) {
-        printf("c Nothing extreme in this problem, continue with glucose default strategies.\n");
+        // printf("c Nothing extreme in this problem, continue with glucose default strategies.\n");
     }
-    printf("c\n");
+    // printf("c\n");
     if(adjusted) { // Let's reinitialize the glucose restart strategy counters
         lbdQueue.fastclear();
         sumLBD = 0;
@@ -1422,7 +1475,7 @@
             }
         }
         learnts.shrink(i - j);
-        printf("c Activating Chanseok Strategy: moved %d clauses to the permanent set.\n", moved);
+        // printf("c Activating Chanseok Strategy: moved %d clauses to the permanent set.\n", moved);
     }
 
     if(reinit) {
@@ -1435,13 +1488,13 @@
 /*
 	order_heap.clear();
 	for(int i=0;i<nVars();i++) {
-	    polarity[i] = true; 
+	    polarity[i] = true;
 	    activity[i]=0.0;
 	    if (decision[i]) order_heap.insert(i);
 	}
 	printf("c reinitialization of all variables activity/phase/learnt clauses.\n");
 */
-        printf("c Removing of non permanent clauses.\n");
+        // printf("c Removing of non permanent clauses.\n");
     }
 
 }
@@ -1450,15 +1503,15 @@
 /*_________________________________________________________________________________________________
 |
 |  search : (nof_conflicts : int) (params : const SearchParams&)  ->  [lbool]
-|  
+|
 |  Description:
-|    Search for a model the specified number of conflicts. 
+|    Search for a model the specified number of conflicts.
 |    NOTE! Use negative value for 'nof_conflicts' indicate infinity.
-|  
+|
 |  Output:
-|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
-|    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
-|    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
+|    'g41l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
+|    all variables are decision variables, this means that the clause set is satisfiable. 'g41l_False'
+|    if the clause set is unsatisfiable. 'g41l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
 lbool Solver::search(int nof_conflicts) {
     assert(ok);
@@ -1475,7 +1528,7 @@
             parallelImportUnaryClauses();
 
             if(parallelImportClauses())
-                return l_False;
+                return g41l_False;
 
         }
         CRef confl = propagate();
@@ -1483,7 +1536,7 @@
         if(confl != CRef_Undef) {
             newDescent = false;
             if(parallelJobIsFinished())
-                return l_Undef;
+                return g41l_Undef;
 
             if(!aDecisionWasMade)
                 stats[noDecisionConflict]++;
@@ -1505,14 +1558,14 @@
                        (int) stats[nbReduceDB], nLearnts(), (int) stats[nbDL2], (int) stats[nbRemovedClauses], progressEstimate() * 100);
             }
             if(decisionLevel() == 0) {
-                return l_False;
+                return g41l_False;
 
             }
             if(adaptStrategies && conflicts == 100000) {
                 cancelUntil(0);
                 adaptSolver();
                 adaptStrategies = false;
-                return l_Undef;
+                return g41l_Undef;
             }
 
             trailQueue.push(trail.size());
@@ -1546,7 +1599,7 @@
                 }
                 else {
                     for(int i = 0; i < learnt_clause.size(); i++)
-                        fprintf(certifiedOutput, "%i ", (var(learnt_clause[i]) + 1) *
+                        fprintf(certifiedOutput, "%i ", var(learnt_clause[i]) *
                                                         (-2 * sign(learnt_clause[i]) + 1));
                     fprintf(certifiedOutput, "0\n");
                 }
@@ -1603,13 +1656,13 @@
                 }
 
                 cancelUntil(bt);
-                return l_Undef;
+                return g41l_Undef;
             }
 
 
             // Simplify the set of problem clauses:
             if(decisionLevel() == 0 && !simplify()) {
-                return l_False;
+                return g41l_False;
             }
             // Perform clause database reduction !
             if((chanseokStrategy && !glureduce && learnts.size() > firstReduceDB) ||
@@ -1628,12 +1681,12 @@
             while(decisionLevel() < assumptions.size()) {
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if(value(p) == l_True) {
+                if(value(p) == g41l_True) {
                     // Dummy decision level:
                     newDecisionLevel();
-                } else if(value(p) == l_False) {
+                } else if(value(p) == g41l_False) {
                     analyzeFinal(~p, conflict);
-                    return l_False;
+                    return g41l_False;
                 } else {
                     next = p;
                     break;
@@ -1645,9 +1698,9 @@
                 decisions++;
                 next = pickBranchLit();
                 if(next == lit_Undef) {
-                    printf("c last restart ## conflicts  :  %d %d \n", conflictC, decisionLevel());
+                    // printf("c last restart ## conflicts  :  %d %d \n", conflictC, decisionLevel());
                     // Model found:
-                    return l_True;
+                    return g41l_True;
                 }
             }
 
@@ -1742,13 +1795,15 @@
 
     model.clear();
     conflict.clear();
-    if(!ok) return l_False;
+    if(!ok) return g41l_False;
     double curTime = cpuTime();
 
     solves++;
 
+    for (int i = 0; i < assumptions.size(); i++)
+      assump[var(assumptions[i])] = true;
 
-    lbool status = l_Undef;
+    lbool status = g41l_Undef;
     if(!incremental && verbosity >= 1) {
         printf("c ========================================[ MAGIC CONSTANTS ]==============================================\n");
         printf("c | Constants are supposed to work well together :-)                                                      |\n");
@@ -1786,7 +1841,7 @@
 
     // Search:
     int curr_restarts = 0;
-    while(status == l_Undef) {
+    while(status == g41l_Undef) {
         status = search(
                 luby_restart ? luby(restart_inc, curr_restarts) * luby_restart_factor : 0); // the parameter is useless in glucose, kept to allow modifications
 
@@ -1798,7 +1853,7 @@
         printf("c =========================================================================================================\n");
 
     if(certifiedUNSAT) { // Want certified output
-        if(status == l_False) {
+        if(status == g41l_False) {
             if(vbyte) {
                 write_char('a');
                 write_lit(0);
@@ -1807,15 +1862,15 @@
                 fprintf(certifiedOutput, "0\n");
             }
         }
-        fclose(certifiedOutput);
+        // fclose(certifiedOutput);
     }
 
 
-    if(status == l_True) {
+    if(status == g41l_True) {
         // Extend & copy model:
         model.growTo(nVars());
         for(int i = 0; i < nVars(); i++) model[i] = value(i);
-    } else if(status == l_False && conflict.size() == 0)
+    } else if(status == g41l_False && conflict.size() == 0)
         ok = false;
 
 
@@ -1823,11 +1878,11 @@
 
 
     double finalTime = cpuTime();
-    if(status == l_True) {
+    if(status == g41l_True) {
         nbSatCalls++;
         totalTime4Sat += (finalTime - curTime);
     }
-    if(status == l_False) {
+    if(status == g41l_False) {
         nbUnsatCalls++;
         totalTime4Unsat += (finalTime - curTime);
     }
@@ -1843,7 +1898,7 @@
 
 //=================================================================================================
 // Writing CNF to DIMACS:
-// 
+//
 // FIXME: this needs to be rewritten completely.
 
 static Var mapVar(Var x, vec <Var> &map, Var &max) {
@@ -1859,7 +1914,7 @@
     if(satisfied(c)) return;
 
     for(int i = 0; i < c.size(); i++)
-        if(value(c[i]) != l_False)
+        if(value(c[i]) != g41l_False)
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max) + 1);
     fprintf(f, "0\n");
 }
@@ -1895,7 +1950,7 @@
         if(!satisfied(ca[clauses[i]])) {
             Clause &c = ca[clauses[i]];
             for(int j = 0; j < c.size(); j++)
-                if(value(c[j]) != l_False)
+                if(value(c[j]) != g41l_False)
                     mapVar(var(c[j]), map, max);
         }
 
@@ -1905,7 +1960,7 @@
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
     for(int i = 0; i < assumptions.size(); i++) {
-        assert(value(assumptions[i]) != l_False);
+        assert(value(assumptions[i]) != g41l_False);
         fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max) + 1);
     }
 
diff -Naur solvers/glucose41/core/Solver.h solvers/g41/core/Solver.h
--- solvers/glucose41/core/Solver.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/core/Solver.h	2018-05-23 14:36:45.000000000 +0100
@@ -9,19 +9,19 @@
                                 Labri - Univ. Bordeaux, France
 
 Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
-Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it
 is based on. (see below).
 
 Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
 version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
 without restriction, including the rights to use, copy, modify, merge, publish, distribute,
-sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 - The above and below copyrights notices and this permission notice shall be included in all
 copies or substantial portions of the Software;
 - The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
-be used in any competitive event (sat competitions/evaluations) without the express permission of 
+be used in any competitive event (sat competitions/evaluations) without the express permission of
 the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
 using Glucose Parallel as an embedded SAT engine (single core or not).
 
@@ -47,26 +47,26 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  **************************************************************************************************/
 
-#ifndef Glucose_Solver_h
-#define Glucose_Solver_h
+#ifndef Glucose41_Solver_h
+#define Glucose41_Solver_h
+
+#include "glucose41/mtl/Heap.h"
+#include "glucose41/mtl/Alg.h"
+#include "glucose41/utils/Options.h"
+#include "glucose41/core/SolverTypes.h"
+#include "glucose41/core/BoundedQueue.h"
+#include "glucose41/core/Constants.h"
+#include "glucose41/mtl/Clone.h"
+#include "glucose41/core/SolverStats.h"
+
+
+namespace Glucose41 {
+// Core stats
 
-#include "mtl/Heap.h"
-#include "mtl/Alg.h"
-#include "utils/Options.h"
-#include "core/SolverTypes.h"
-#include "core/BoundedQueue.h"
-#include "core/Constants.h"
-#include "mtl/Clone.h"
-#include "core/SolverStats.h"
-
-
-namespace Glucose {
-// Core stats 
-    
 enum CoreStats {
   sumResSeen,
   sumRes,
-  sumTrail,  
+  sumTrail,
   nbPromoted,
   originalClausesSeen,
   sumDecisionLevels,
@@ -104,24 +104,24 @@
     //
     Solver();
     Solver(const  Solver &s);
-    
+
     virtual ~Solver();
-    
+
     /**
      * Clone function
      */
     virtual Clone* clone() const {
         return  new Solver(*this);
-    }   
+    }
 
     // Problem specification:
     //
     virtual Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
-    bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver. 
+    bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver.
     bool    addEmptyClause();                                   // Add the empty clause, making the solver contradictory.
-    bool    addClause (Lit p);                                  // Add a unit clause to the solver. 
-    bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver. 
-    bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver. 
+    bool    addClause (Lit p);                                  // Add a unit clause to the solver.
+    bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver.
+    bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver.
     virtual bool    addClause_(      vec<Lit>& ps);                     // Add a clause to the solver without making superflous internal copy. Will
                                                                 // change the passed vector 'ps'.
     // Solving:
@@ -134,6 +134,7 @@
     bool    solve        (Lit p, Lit q);            // Search for a model that respects two assumptions.
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
+    bool    prop_check   (const vec<Lit>& assumps, vec<Lit>& prop, int psaving = 0); // compute a list of propagated literals given a set of assumptions
 
        // Convenience versions of 'toDimacs()':
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
@@ -143,14 +144,14 @@
     void    toDimacs     (const char* file, Lit p);
     void    toDimacs     (const char* file, Lit p, Lit q);
     void    toDimacs     (const char* file, Lit p, Lit q, Lit r);
- 
+
     // Display clauses and literals
     void printLit(Lit l);
     void printClause(CRef c);
     void printInitialClause(CRef c);
-    
+
     // Variable mode:
-    // 
+    //
     void    setPolarity    (Var v, bool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
     void    setDecisionVar (Var v, bool b); // Declare if a variable should be eligible for selection in the decision heuristic.
 
@@ -198,7 +199,7 @@
     int       verbosity;
     int       verbEveryConflicts;
     int       showModel;
-    
+
     // Constants For restarts
     double    K;
     double    R;
@@ -228,13 +229,14 @@
     bool      rnd_init_act;       // Initialize variable activities with a small random value.
     bool      randomizeFirstDescent; // the first decisions (until first cnflict) are made randomly
                                      // Useful for syrup!
-    
+
     // Constant for Memory managment
     double    garbage_frac;       // The fraction of wasted memory allowed before a garbage collection is triggered.
 
     // Certified UNSAT ( Thanks to Marijn Heule
     // New in 2016 : proof in DRAT format, possibility to use binary output
     FILE*               certifiedOutput;
+    void*               certifiedPyFile;
     bool                certifiedUNSAT;
     bool                vbyte;
 
@@ -242,15 +244,15 @@
     void write_lit (int n);
 
 
-    // Panic mode. 
+    // Panic mode.
     // Save memory
     uint32_t panicModeLastRemoved, panicModeLastRemovedShared;
-    
+
     bool useUnaryWatched;            // Enable unary watched literals
     bool promoteOneWatchedClause;    // One watched clauses are promotted to two watched clauses if found empty
-    
+
     // Functions useful for multithread solving
-    // Useless in the sequential case 
+    // Useless in the sequential case
     // Overide in ParallelSolver
     virtual void parallelImportClauseDuringConflictAnalysis(Clause &c,CRef confl);
     virtual bool parallelImportClauses(); // true if the empty clause was received
@@ -259,13 +261,13 @@
     virtual void parallelExportClauseDuringSearch(Clause &c);
     virtual bool parallelJobIsFinished();
     virtual bool panicModeIsEnabled();
-    
-    
+
+
     double luby(double y, int x);
-    
-    // Statistics 
+
+    // Statistics
     vec<uint64_t> stats;
-    
+
     // Important stats completely related to search. Keep here
     uint64_t solves,starts,decisions,propagations,conflicts,conflictsRestarts;
 
@@ -334,6 +336,7 @@
     vec<CRef>           unaryWatchedClauses;  // List of imported clauses (after the purgatory) // TODO put inside ParallelSolver
 
     vec<lbool>          assigns;          // The current assignments.
+    vec<bool>           assump;           // Declares if a variable is an assumption variable or not.
     vec<char>           polarity;         // The preferred polarity of each variable.
     vec<char>           forceUNSAT;
     void                bumpForceUNSAT(Lit q); // Handles the forces
@@ -351,15 +354,15 @@
     double              progress_estimate;// Set by 'search()'.
     bool                remove_satisfied; // Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.
     vec<unsigned int>   permDiff;           // permDiff[var] contains the current conflict number... Used to count the number of  LBD
-    
+
 
     // UPDATEVARACTIVITY trick (see competition'09 companion paper)
-    vec<Lit> lastDecisionLevel; 
+    vec<Lit> lastDecisionLevel;
 
     ClauseAllocator     ca;
 
     int nbclausesbeforereduce;            // To know when it is time to reduce clause database
-    
+
     // Used for restart strategies
     bqueue<unsigned int> trailQueue,lbdQueue; // Bounded queues for restarts.
     float sumLBD; // used to compute the global average of LBD. Restarts...
@@ -447,7 +450,7 @@
     int      level            (Var x) const;
     double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
     bool     withinBudget     ()      const;
-    inline bool isSelector(Var v) {return (incremental && v>nbVarsInitialFormula);}
+    inline bool isSelector(Var v) { return (incremental && assump[v]); }
 
     // Static helpers:
     //
@@ -501,19 +504,19 @@
         garbageCollect(); }
 
 // NOTE: enqueue does not set the ok flag! (only public methods do)
-inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }
+inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != g41l_Undef ? value(p) != g41l_False : (uncheckedEnqueue(p, from), true); }
 inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
 inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
- inline bool     Solver::locked          (const Clause& c) const { 
-   if(c.size()>2) 
-     return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; 
-   return 
-     (value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c)
-     || 
-     (value(c[1]) == l_True && reason(var(c[1])) != CRef_Undef && ca.lea(reason(var(c[1]))) == &c);
+ inline bool     Solver::locked          (const Clause& c) const {
+   if(c.size()>2)
+     return value(c[0]) == g41l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c;
+   return
+     (value(c[0]) == g41l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c)
+     ||
+     (value(c[1]) == g41l_True && reason(var(c[1])) != CRef_Undef && ca.lea(reason(var(c[1]))) == &c);
  }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
@@ -527,12 +530,12 @@
 inline int      Solver::nClauses      ()      const   { return clauses.size(); }
 inline int      Solver::nLearnts      ()      const   { return learnts.size(); }
 inline int      Solver::nVars         ()      const   { return vardata.size(); }
-inline int      Solver::nFreeVars     ()         { 
+inline int      Solver::nFreeVars     ()         {
     int a = stats[dec_vars];
     return (int)(a) - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
 inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
-inline void     Solver::setDecisionVar(Var v, bool b) 
-{ 
+inline void     Solver::setDecisionVar(Var v, bool b)
+{
     if      ( b && !decision[v]) stats[dec_vars]++;
     else if (!b &&  decision[v]) stats[dec_vars]--;
 
@@ -552,11 +555,11 @@
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
 // all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.
-inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }
-inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }
+inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == g41l_True; }
+inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == g41l_True; }
+inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == g41l_True; }
+inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == g41l_True; }
+inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == g41l_True; }
 inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }
 inline bool     Solver::okay          ()      const   { return ok; }
 
@@ -566,14 +569,13 @@
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }
 
 
-
 //=================================================================================================
 // Debug etc:
 
 
 inline void Solver::printLit(Lit l)
 {
-    printf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == l_True ? '1' : (value(l) == l_False ? '0' : 'X'));
+    printf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == g41l_True ? '1' : (value(l) == g41l_False ? '0' : 'X'));
 }
 
 
@@ -639,7 +641,7 @@
         return ca[x].activity() < ca[y].activity();
         //return x->size() < y->size();
 
-        //return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity()); } 
+        //return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity()); }
     }
 };
 
diff -Naur solvers/glucose41/core/SolverStats.h solvers/g41/core/SolverStats.h
--- solvers/glucose41/core/SolverStats.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/core/SolverStats.h	2018-05-21 10:14:01.000000000 +0100
@@ -47,12 +47,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  **************************************************************************************************/
 
-#ifndef SOLVERSTATS_H
-#define	SOLVERSTATS_H
+#ifndef Glucose41_SolverStats_h
+#define	Glucose41_SolverStats_h
 
-#include "mtl/Map.h"
+#include "glucose41/mtl/Map.h"
 #include <string>
-namespace Glucose {
+namespace Glucose41 {
 
     class SolverStats {
     protected:
@@ -95,5 +95,5 @@
 
 }
 
-#endif	/* SOLVERSTATS_H */
+#endif	/* Glucose41_SolverStats_h */
 
diff -Naur solvers/glucose41/core/SolverTypes.h solvers/g41/core/SolverTypes.h
--- solvers/glucose41/core/SolverTypes.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/core/SolverTypes.h	2018-05-21 10:14:01.000000000 +0100
@@ -9,19 +9,19 @@
                                 Labri - Univ. Bordeaux, France
 
 Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
-Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
+Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it
 is based on. (see below).
 
 Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
 version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
 without restriction, including the rights to use, copy, modify, merge, publish, distribute,
-sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
+sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 - The above and below copyrights notices and this permission notice shall be included in all
 copies or substantial portions of the Software;
 - The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
-be used in any competitive event (sat competitions/evaluations) without the express permission of 
+be used in any competitive event (sat competitions/evaluations) without the express permission of
 the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
 using Glucose Parallel as an embedded SAT engine (single core or not).
 
@@ -48,21 +48,21 @@
  **************************************************************************************************/
 
 
-#ifndef Glucose_SolverTypes_h
-#define Glucose_SolverTypes_h
+#ifndef Glucose41_SolverTypes_h
+#define Glucose41_SolverTypes_h
 
 #include <assert.h>
 #include <stdint.h>
 #include <pthread.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Alg.h"
-#include "mtl/Vec.h"
-#include "mtl/Map.h"
-#include "mtl/Alloc.h"
+#include "glucose41/mtl/IntTypes.h"
+#include "glucose41/mtl/Alg.h"
+#include "glucose41/mtl/Vec.h"
+#include "glucose41/mtl/Map.h"
+#include "glucose41/mtl/Alloc.h"
 
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Variables, literals, lifted booleans, clauses:
@@ -94,9 +94,9 @@
 inline  int  var       (Lit p)              { return p.x >> 1; }
 
 // Mapping Literals to and from compact integers suitable for array indexing:
-inline  int  toInt     (Var v)              { return v; } 
-inline  int  toInt     (Lit p)              { return p.x; } 
-inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
+inline  int  toInt     (Var v)              { return v; }
+inline  int  toInt     (Lit p)              { return p.x; }
+inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; }
 
 //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
 //const Lit lit_Error = mkLit(var_Undef, true );  // }
@@ -109,13 +109,13 @@
 // Lifted booleans:
 //
 // NOTE: this implementation is optimized for the case when comparisons between values are mostly
-//       between one variable and one constant. Some care had to be taken to make sure that gcc 
+//       between one variable and one constant. Some care had to be taken to make sure that gcc
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
-#define l_True  (Glucose::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-#define l_False (Glucose::lbool((uint8_t)1))
-#define l_Undef (Glucose::lbool((uint8_t)2))
+#define g41l_True  (Glucose41::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+#define g41l_False (Glucose41::lbool((uint8_t)1))
+#define g41l_Undef (Glucose41::lbool((uint8_t)2))
 
 class lbool {
     uint8_t value;
@@ -130,7 +130,7 @@
     bool  operator != (lbool b) const { return !(*this == b); }
     lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
 
-    lbool operator && (lbool b) const { 
+    lbool operator && (lbool b) const {
         uint8_t sel = (this->value << 1) | (b.value << 3);
         uint8_t v   = (0xF7F755F4 >> sel) & 3;
         return lbool(v); }
@@ -152,7 +152,7 @@
 class Clause;
 typedef RegionAllocator<uint32_t>::Ref CRef;
 
-#define BITS_LBD 20 
+#define BITS_LBD 20
 #ifdef INCREMENTAL
   #define BITS_SIZEWITHOUTSEL 19
 #endif
@@ -162,7 +162,7 @@
       unsigned mark       : 2;
       unsigned learnt     : 1;
       unsigned canbedel   : 1;
-      unsigned extra_size : 2; // extra size (end of 32bits) 0..3       
+      unsigned extra_size : 2; // extra size (end of 32bits) 0..3
       unsigned seen       : 1;
       unsigned reloced    : 1;
       unsigned exported   : 2; // Values to keep track of the clause status for exportations
@@ -191,20 +191,20 @@
         header.size      = ps.size();
 	header.lbd = 0;
 	header.canbedel = 1;
-	header.exported = 0; 
+	header.exported = 0;
 	header.oneWatched = 0;
 	header.seen = 0;
-        for (int i = 0; i < ps.size(); i++) 
+        for (int i = 0; i < ps.size(); i++)
             data[i].lit = ps[i];
-	
+
         if (header.extra_size > 0){
-	  if (header.learnt) 
-                data[header.size].act = 0; 
-            else 
+	  if (header.learnt)
+                data[header.size].act = 0;
+            else
                 calcAbstraction();
 	  if (header.extra_size > 1) {
 	      data[header.size+1].abs = 0; // learntFrom
-	  }	      
+	  }
 	}
     }
 
@@ -217,7 +217,7 @@
         data[header.size].abs = abstraction;  }
 
     int          size        ()      const   { return header.size; }
-    void         shrink      (int i)         { assert(i <= size()); 
+    void         shrink      (int i)         { assert(i <= size());
 						if (header.extra_size > 0) {
 						    data[header.size-i] = data[header.size];
 						    if (header.extra_size > 1) { // Special case for imported clauses
@@ -253,7 +253,7 @@
 
     Lit          subsumes    (const Clause& other) const;
     void         strengthen  (Lit p);
-    void         setLBD(int i)  {header.lbd=i; /*if (i < (1<<(BITS_LBD-1))) header.lbd = i; else header.lbd = (1<<(BITS_LBD-1));*/} 
+    void         setLBD(int i)  {header.lbd=i; /*if (i < (1<<(BITS_LBD-1))) header.lbd = i; else header.lbd = (1<<(BITS_LBD-1));*/}
     // unsigned int&       lbd    ()              { return header.lbd; }
     unsigned int        lbd    () const        { return header.lbd; }
     void setCanBeDel(bool b) {header.canbedel = b;}
@@ -264,7 +264,7 @@
     unsigned int getExported() {return header.exported;}
     void setOneWatched(bool b) {header.oneWatched = b;}
     bool getOneWatched() {return header.oneWatched;}
-#ifdef INCREMNENTAL
+#ifdef INCREMENTAL
     void setSizeWithoutSelectors   (unsigned int n)              {header.szWithoutSelectors = n; }
     unsigned int        sizeWithoutSelectors   () const        { return header.szWithoutSelectors; }
 #endif
@@ -364,7 +364,7 @@
 
  public:
     OccLists(const Deleted& d) : deleted(d) {}
-    
+
     void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
     // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
     Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
@@ -372,7 +372,7 @@
 
     void  cleanAll  ();
     void copyTo(OccLists &copy) const {
-	
+
 	copy.occs.growTo(occs.size());
 	for(int i = 0;i<occs.size();i++)
 	    occs[i].memCopyTo(copy.occs[i]);
@@ -432,13 +432,13 @@
 
     typedef Map<CRef, T, CRefHash> HashTable;
     HashTable map;
-        
+
  public:
     // Size-operations:
     void     clear       ()                           { map.clear(); }
     int      size        ()                const      { return map.elems(); }
 
-    
+
     // Insert/Remove/Test mapping:
     void     insert      (CRef cr, const T& t){ map.insert(cr, t); }
     void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } // NOTE: for compatibility
@@ -465,11 +465,11 @@
 /*_________________________________________________________________________________________________
 |
 |  subsumes : (other : const Clause&)  ->  Lit
-|  
+|
 |  Description:
 |       Checks if clause subsumes 'other', and at the same time, if it can be used to simplify 'other'
 |       by subsumption resolution.
-|  
+|
 |    Result:
 |       lit_Error  - No subsumption or simplification
 |       lit_Undef  - Clause subsumes 'other'
@@ -511,9 +511,9 @@
     remove(*this, p);
     calcAbstraction();
 }
- 
+
 //=================================================================================================
 }
 
- 
+
 #endif
diff -Naur solvers/glucose41/mtl/Alg.h solvers/g41/mtl/Alg.h
--- solvers/glucose41/mtl/Alg.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Alg.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Alg_h
-#define Glucose_Alg_h
+#ifndef Glucose41_Alg_h
+#define Glucose41_Alg_h
 
-#include "mtl/Vec.h"
+#include "glucose41/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Useful functions on vector-like types:
diff -Naur solvers/glucose41/mtl/Alloc.h solvers/g41/mtl/Alloc.h
--- solvers/glucose41/mtl/Alloc.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Alloc.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Glucose_Alloc_h
-#define Glucose_Alloc_h
+#ifndef Glucose41_Alloc_h
+#define Glucose41_Alloc_h
 
-#include "mtl/XAlloc.h"
-#include "mtl/Vec.h"
+#include "glucose41/mtl/XAlloc.h"
+#include "glucose41/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Simple Region-based memory allocator:
diff -Naur solvers/glucose41/mtl/Clone.h solvers/g41/mtl/Clone.h
--- solvers/glucose41/mtl/Clone.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Clone.h	2018-05-21 10:14:01.000000000 +0100
@@ -1,8 +1,8 @@
-#ifndef Glucose_Clone_h
-#define Glucose_Clone_h
+#ifndef Glucose41_Clone_h
+#define Glucose41_Clone_h
 
 
-namespace Glucose {
+namespace Glucose41 {
 
     class Clone {
         public:
diff -Naur solvers/glucose41/mtl/Heap.h solvers/g41/mtl/Heap.h
--- solvers/glucose41/mtl/Heap.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Heap.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Heap_h
-#define Glucose_Heap_h
+#ifndef Glucose41_Heap_h
+#define Glucose41_Heap_h
 
-#include "mtl/Vec.h"
+#include "glucose41/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // A heap implementation with support for decrease/increase key.
diff -Naur solvers/glucose41/mtl/IntTypes.h solvers/g41/mtl/IntTypes.h
--- solvers/glucose41/mtl/IntTypes.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/IntTypes.h	2018-05-21 10:14:01.000000000 +0100
@@ -17,8 +17,8 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_IntTypes_h
-#define Glucose_IntTypes_h
+#ifndef Glucose41_IntTypes_h
+#define Glucose41_IntTypes_h
 
 #ifdef __sun
     // Not sure if there are newer versions that support C99 headers. The
diff -Naur solvers/glucose41/mtl/Map.h solvers/g41/mtl/Map.h
--- solvers/glucose41/mtl/Map.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Map.h	2018-05-21 10:14:01.000000000 +0100
@@ -17,15 +17,15 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Map_h
-#define Glucose_Map_h
+#ifndef Glucose41_Map_h
+#define Glucose41_Map_h
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
+#include "glucose41/mtl/IntTypes.h"
+#include "glucose41/mtl/Vec.h"
 #include <string>
 #include <unordered_map>
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Default hash/equals functions
diff -Naur solvers/glucose41/mtl/Queue.h solvers/g41/mtl/Queue.h
--- solvers/glucose41/mtl/Queue.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Queue.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Queue_h
-#define Glucose_Queue_h
+#ifndef Glucose41_Queue_h
+#define Glucose41_Queue_h
 
-#include "mtl/Vec.h"
+#include "glucose41/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 
diff -Naur solvers/glucose41/mtl/Sort.h solvers/g41/mtl/Sort.h
--- solvers/glucose41/mtl/Sort.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Sort.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Sort_h
-#define Glucose_Sort_h
+#ifndef Glucose41_Sort_h
+#define Glucose41_Sort_h
 
-#include "mtl/Vec.h"
+#include "glucose41/mtl/Vec.h"
 
 //=================================================================================================
 // Some sorting algorithms for vec's
 
 
-namespace Glucose {
+namespace Glucose41 {
 
 template<class T>
 struct LessThan_default {
diff -Naur solvers/glucose41/mtl/Vec.h solvers/g41/mtl/Vec.h
--- solvers/glucose41/mtl/Vec.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/Vec.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,17 +18,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Vec_h
-#define Glucose_Vec_h
+#ifndef Glucose41_Vec_h
+#define Glucose41_Vec_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
-#include<string.h>
+#include "glucose41/mtl/IntTypes.h"
+#include "glucose41/mtl/XAlloc.h"
+#include <string.h>
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Automatically resizable arrays
@@ -44,7 +44,7 @@
     // Don't allow copying (error prone):
     vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              vec        (vec<T>& other) { assert(0); }
-             
+
     // Helpers for calculating next capacity:
     static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
     //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
@@ -75,11 +75,11 @@
     void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
     void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
     void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
-    
+
     void     remove(const T &elem) {
         int tmp;
         for(tmp = 0;tmp<sz;tmp++) {
-            if(data[tmp]==elem) 
+            if(data[tmp]==elem)
                 break;
         }
         if(tmp<sz) {
@@ -87,9 +87,9 @@
             data[tmp] = data[sz-1];
             sz = sz - 1;
         }
-        
+
     }
-    
+
     // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
     // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
     // happen given the way capacities are calculated (below). Essentially, all capacities are
@@ -118,7 +118,7 @@
 void vec<T>::capacity(int min_cap) {
     if (cap >= min_cap) return;
     int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
-    if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
+    if (add > INT_MAX - cap || (((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM))
         throw OutOfMemoryException();
  }
 
diff -Naur solvers/glucose41/mtl/VecThreads.h solvers/g41/mtl/VecThreads.h
--- solvers/glucose41/mtl/VecThreads.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/VecThreads.h	2018-05-21 10:14:01.000000000 +0100
@@ -1,5 +1,5 @@
 /*******************************************************************************************[VecThreads.h]
- * Threads safe  version used in Glucose-Syrup, 2015, Gilles Audemard, Laurent Simon
+ * Threads safe  version used in Glucose41-Syrup, 2015, Gilles Audemard, Laurent Simon
 Copyright (c) 2003-2007, Niklas Een, Niklas Sorensson
 Copyright (c) 2007-2010, Niklas Sorensson
 
@@ -19,17 +19,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_VecThreads_h
-#define Glucose_VecThreads_h
+#ifndef Glucose41_VecThreads_h
+#define Glucose41_VecThreads_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
-#include<string.h>
+#include "glucose41/mtl/IntTypes.h"
+#include "glucose41/mtl/XAlloc.h"
+#include <string.h>
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Automatically resizable arrays
diff -Naur solvers/glucose41/mtl/XAlloc.h solvers/g41/mtl/XAlloc.h
--- solvers/glucose41/mtl/XAlloc.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/mtl/XAlloc.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,14 +18,14 @@
 **************************************************************************************************/
 
 
-#ifndef Glucose_XAlloc_h
-#define Glucose_XAlloc_h
+#ifndef Glucose41_XAlloc_h
+#define Glucose41_XAlloc_h
 
 #include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
 
-namespace Glucose {
+namespace Glucose41 {
 
 //=================================================================================================
 // Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
diff -Naur solvers/glucose41/utils/Options.cc solvers/g41/utils/Options.cc
--- solvers/glucose41/utils/Options.cc	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/utils/Options.cc	2018-05-21 10:14:01.000000000 +0100
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "mtl/Sort.h"
-#include "utils/Options.h"
-#include "utils/ParseUtils.h"
+#include "glucose41/mtl/Sort.h"
+#include "glucose41/utils/Options.h"
+#include "glucose41/utils/ParseUtils.h"
 
-using namespace Glucose;
+using namespace Glucose41;
 
-void Glucose::parseOptions(int& argc, char** argv, bool strict)
+void Glucose41::parseOptions(int& argc, char** argv, bool strict)
 {
     int i, j;
     for (i = j = 1; i < argc; i++){
@@ -35,18 +35,19 @@
                 printUsageAndExit(argc, argv, true);
         } else {
             bool parsed_ok = false;
-        
+
             for (int k = 0; !parsed_ok && k < Option::getOptionList().size(); k++){
                 parsed_ok = Option::getOptionList()[k]->parse(argv[i]);
 
                 // fprintf(stderr, "checking %d: %s against flag <%s> (%s)\n", i, argv[i], Option::getOptionList()[k]->name, parsed_ok ? "ok" : "skip");
             }
 
-            if (!parsed_ok)
+            if (!parsed_ok) {
                 if (strict && match(argv[i], "-"))
                     fprintf(stderr, "ERROR! Unknown flag \"%s\". Use '--%shelp' for help.\n", argv[i], Option::getHelpPrefixString()), exit(1);
                 else
                     argv[j++] = argv[i];
+            }
         }
     }
 
@@ -54,9 +55,9 @@
 }
 
 
-void Glucose::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
-void Glucose::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Glucose::printUsageAndExit (int argc, char** argv, bool verbose)
+void Glucose41::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void Glucose41::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void Glucose41::printUsageAndExit (int argc, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
diff -Naur solvers/glucose41/utils/Options.h solvers/g41/utils/Options.h
--- solvers/glucose41/utils/Options.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/utils/Options.h	2018-05-21 10:14:01.000000000 +0100
@@ -17,19 +17,19 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Options_h
-#define Glucose_Options_h
+#ifndef Glucose41_Options_h
+#define Glucose41_Options_h
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
-#include "utils/ParseUtils.h"
+#include "glucose41/mtl/IntTypes.h"
+#include "glucose41/mtl/Vec.h"
+#include "glucose41/utils/ParseUtils.h"
 
-namespace Glucose {
+namespace Glucose41 {
 
 //==================================================================================================
 // Top-level option parse/help functions:
@@ -60,20 +60,20 @@
     struct OptionLt {
         bool operator()(const Option* x, const Option* y) {
             int test1 = strcmp(x->category, y->category);
-            return test1 < 0 || test1 == 0 && strcmp(x->type_name, y->type_name) < 0;
+            return test1 < 0 || (test1 == 0 && strcmp(x->type_name, y->type_name) < 0);
         }
     };
 
-    Option(const char* name_, 
+    Option(const char* name_,
            const char* desc_,
            const char* cate_,
-           const char* type_) : 
+           const char* type_) :
       name       (name_)
     , description(desc_)
     , category   (cate_)
     , type_name  (type_)
-    { 
-        getOptionList().push(this); 
+    {
+        getOptionList().push(this);
     }
 
  public:
@@ -135,7 +135,7 @@
     DoubleOption& operator=(double x)   { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -143,7 +143,7 @@
         char*  end;
         double tmp = strtod(span, &end);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp >= range.end && (!range.end_inclusive || tmp != range.end)){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -159,12 +159,12 @@
     }
 
     virtual void help (bool verbose = false){
-        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n", 
-                name, type_name, 
-                range.begin_inclusive ? '[' : '(', 
+        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n",
+                name, type_name,
+                range.begin_inclusive ? '[' : '(',
                 range.begin,
                 range.end,
-                range.end_inclusive ? ']' : ')', 
+                range.end_inclusive ? ']' : ')',
                 value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
@@ -187,13 +187,13 @@
  public:
     IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))
         : Option(n, d, c, "<int32>"), range(r), value(def) {}
- 
+
     operator   int32_t   (void) const { return value; }
     operator   int32_t&  (void)       { return value; }
     IntOption& operator= (int32_t x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -201,7 +201,7 @@
         char*   end;
         int32_t tmp = strtol(span, &end, 10);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp > range.end){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -249,13 +249,13 @@
  public:
     Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))
         : Option(n, d, c, "<int64>"), range(r), value(def) {}
- 
+
     operator     int64_t   (void) const { return value; }
     operator     int64_t&  (void)       { return value; }
     Int64Option& operator= (int64_t x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -263,7 +263,7 @@
         char*   end;
         int64_t tmp = strtoll(span, &end, 10);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp > range.end){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -307,7 +307,7 @@
 {
     const char* value;
  public:
-    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) 
+    StringOption(const char* c, const char* n, const char* d, const char* def = NULL)
         : Option(n, d, c, "<string>"), value(def) {}
 
     operator      const char*  (void) const     { return value; }
@@ -315,7 +315,7 @@
     StringOption& operator=    (const char* x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -330,7 +330,7 @@
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
         }
-    }    
+    }
 };
 
 
@@ -343,7 +343,7 @@
     bool value;
 
  public:
-    BoolOption(const char* c, const char* n, const char* d, bool v) 
+    BoolOption(const char* c, const char* n, const char* d, bool v)
         : Option(n, d, c, "<bool>"), value(v) {}
 
     operator    bool     (void) const { return value; }
@@ -351,8 +351,8 @@
     BoolOption& operator=(bool b)     { value = b; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
-        
+        const char* span = str;
+
         if (match(span, "-")){
             bool b = !match(span, "no-");
 
diff -Naur solvers/glucose41/utils/ParseUtils.h solvers/g41/utils/ParseUtils.h
--- solvers/glucose41/utils/ParseUtils.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/utils/ParseUtils.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,8 +18,8 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_ParseUtils_h
-#define Glucose_ParseUtils_h
+#ifndef Glucose41_ParseUtils_h
+#define Glucose41_ParseUtils_h
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -27,7 +27,7 @@
 
 #include <zlib.h>
 
-namespace Glucose {
+namespace Glucose41 {
 
 //-------------------------------------------------------------------------------------------------
 // A simple buffered character stream class:
diff -Naur solvers/glucose41/utils/System.cc solvers/g41/utils/System.cc
--- solvers/glucose41/utils/System.cc	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/utils/System.cc	2018-05-21 10:14:01.000000000 +0100
@@ -18,14 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "utils/System.h"
+#include "glucose41/utils/System.h"
 
 #if defined(__linux__)
 
 #include <stdio.h>
 #include <stdlib.h>
 
-using namespace Glucose;
+using namespace Glucose41;
 
 // TODO: split the memory reading functions into two: one for reading high-watermark of RSS, and
 // one for reading the current virtual memory size.
@@ -67,14 +67,14 @@
     return peak_kb;
 }
 
-double Glucose::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
-double Glucose::memUsedPeak() { 
+double Glucose41::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double Glucose41::memUsedPeak() { 
     double peak = memReadPeak() / 1024;
     return peak == 0 ? memUsed() : peak; }
 
 #elif defined(__FreeBSD__)
 
-double Glucose::memUsed(void) {
+double Glucose41::memUsed(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
@@ -84,12 +84,12 @@
 #elif defined(__APPLE__)
 #include <malloc/malloc.h>
 
-double Glucose::memUsed(void) {
+double Glucose41::memUsed(void) {
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
 
 #else
-double Glucose::memUsed() { 
+double Glucose41::memUsed() { 
     return 0; }
 #endif
diff -Naur solvers/glucose41/utils/System.h solvers/g41/utils/System.h
--- solvers/glucose41/utils/System.h	2016-12-08 12:48:26.000000000 +0000
+++ solvers/g41/utils/System.h	2018-05-21 10:14:01.000000000 +0100
@@ -18,18 +18,18 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_System_h
-#define Glucose_System_h
+#ifndef Glucose41_System_h
+#define Glucose41_System_h
 
 #if defined(__linux__)
 #include <fpu_control.h>
 #endif
 
-#include "mtl/IntTypes.h"
+#include "glucose41/mtl/IntTypes.h"
 
 //-------------------------------------------------------------------------------------------------
 
-namespace Glucose {
+namespace Glucose41 {
 
 static inline double cpuTime(void); // CPU-time in seconds.
 static inline double realTime(void);
@@ -44,14 +44,14 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #include <time.h>
 
-static inline double Glucose::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+static inline double Glucose41::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
 
 #else
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <unistd.h>
 
-static inline double Glucose::cpuTime(void) {
+static inline double Glucose41::cpuTime(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
@@ -59,7 +59,7 @@
 #endif
 
 // Laurent: I know that this will not compile directly under Windows... sorry for that
-static inline double Glucose::realTime() {
+static inline double Glucose41::realTime() {
     struct timeval tv;
     gettimeofday(&tv, NULL);
     return (double)tv.tv_sec + (double) tv.tv_usec / 1000000; }
